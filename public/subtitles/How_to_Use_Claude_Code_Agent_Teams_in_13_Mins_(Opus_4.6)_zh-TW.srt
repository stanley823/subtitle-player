1
00:00:00,080 --> 00:00:12,756
三天前我發佈了一支展示 Claude Code 各個層級的影片
引起很大迴響
但我遺漏了一個關鍵的東西
如果你要正確使用 Claude Code 必須了解它
那就是 Agent Teams

2
00:00:12,856 --> 00:00:20,743
從那時起，我深入研究了官方文件
也做了大量實測
一旦搞懂之後
完全改變了我對 Claude Code 用在專案上的思維

3
00:00:20,843 --> 00:00:27,040
因為如果你跟大多數人一樣
只用單一代理來跑
你可能已經注意到跟我一樣的問題
跑得越久，效果越差

4
00:00:27,040 --> 00:00:31,420
它會忘記上下文、引入 bug
還逼你不斷重複自己說過的話

5
00:00:31,520 --> 00:00:45,310
所以這支影片裡
我會拆解 Claude 的 Agent Teams 到底是什麼
為什麼存在
以及什麼時候該用 Agent Teams、子代理還是單一代理
讓你能更快建構可靠的系統

6
00:00:45,410 --> 00:00:53,360
那我們直接開始
你塞進單一代理上下文視窗的資訊越多
它的表現就越差
模型就越難專注在當下真正重要的事情上

7
00:00:53,360 --> 00:01:01,269
當這個小小的上下文進度條填滿時
你就會遇到上下文溢出
當它到達 95% 左右
就會壓縮和摘要重要資訊

8
00:01:01,369 --> 00:01:08,772
接下來的對話只使用摘要
這意味著它最終無法再找到
你在幾千個 token 之前給它的關鍵細節

9
00:01:08,872 --> 00:01:18,800
想像一下在一個更大的專案中
所有關鍵細節都很重要
而不只是讓 Claude Code 執行一個獨立的任務
這會造成多大的損害

10
00:01:18,800 --> 00:01:27,123
所以單一代理會不堪負荷、會遺忘
社群中的專家很早就發現了這個問題
開始建構自己的子代理

11
00:01:27,223 --> 00:01:34,531
使用子代理基本上只有兩個原因
第一個是提升輸出品質
就像是聘請專家而不是通才

12
00:01:34,631 --> 00:01:43,360
我們可以讓一個 Claude 負責委派工作
給同一個工作階段中
有自己上下文視窗的專門實例
因此可以提升輸出品質，同時也降低成本

13
00:01:43,360 --> 00:01:51,063
因為我們不需要把所有上下文
都餵給那些專門的子代理

14
00:01:51,163 --> 00:01:59,618
第二個原因是加快速度
不是讓它們來回傳遞
而是讓它們平行運作
開兩個終端機視窗，處理不相依的任務

15
00:01:59,718 --> 00:02:10,240
比如說，終端機一負責寫 LinkedIn 貼文
終端機二同時平行處理 Instagram 貼文
這兩者通常是不相關的

16
00:02:10,240 --> 00:02:20,158
像 Boris Cherny，Claude Code 的創造者
還有社群中其他進階使用者
他們透過建構自己的子代理系統來解決這個問題

17
00:02:20,258 --> 00:02:27,851
Boris 甚至說他同時跑了 15 個代理
終端機裡五個平行運作
然後線上同時開五到十個 Claude

18
00:02:27,951 --> 00:02:33,840
這在理論上很棒
但當代理之間真的需要互相溝通時就崩潰了
因為子代理只能向上級回報

19
00:02:33,840 --> 00:02:41,004
假設我們有一個內容研究團隊
研究員是子代理一，寫手是主要實例
審稿員是子代理二

20
00:02:41,104 --> 00:02:53,495
子代理——研究員和審稿員
只能把資訊回傳給主要實例，也就是寫手
審稿員沒辦法審查研究內容
研究員也看不到審稿員的任何輸出
全部由寫手處理

21
00:02:53,595 --> 00:03:01,920
所以使用子代理時
你最終會發現主要代理變成了瓶頸
主要代理和每個專門子代理之間只有雙向溝通

22
00:03:01,920 --> 00:03:12,360
當我們啟動子代理時
每個子代理有自己的上下文
結果回傳給主要代理
在我們的例子裡就是寫手
然後審稿員和研究員是子代理

23
00:03:12,460 --> 00:03:20,580
但主要代理要協調所有工作
所以當多個任務和多個子代理都匯入主要代理時
那就成了明顯的瓶頸

24
00:03:20,680 --> 00:03:29,960
而且這只在你不需要研究員和審稿員互動時才行得通
所以子代理就像是中心輻射模型
它們給了我們委派的能力

25
00:03:30,200 --> 00:03:36,264
但沒有給我們協作能力
而這正是 Agent Teams 填補的缺口

26
00:03:36,364 --> 00:03:48,491
它們透過共享任務清單來實現這一點
主要代理會決定並啟動隊友
基本上就是我們的子代理
但差別在於它們有共享任務清單
可以跟每個隊友來回溝通

27
00:03:48,591 --> 00:03:59,960
而且不只如此，隊友之間也能互相溝通
你可以把它想成子代理結構
但多了一個能力
不只能跟主要代理溝通
還能從共享任務清單中領取任務

28
00:04:00,040 --> 00:04:10,281
並且跟彼此溝通
所以它們同樣有自己的上下文視窗
但不是把所有資訊回傳給主要代理
而是被設定為自己的 Claude Code 實例

29
00:04:10,381 --> 00:04:17,767
但這也有缺點
它們能存取主要代理所能存取的一切
包括 Claude.md 檔案、MCP 等等

30
00:04:17,867 --> 00:04:24,918
但代價是我們必須把這些全部
放進每個啟動的隊友的上下文中
所以最終會花費更多 token

31
00:04:25,018 --> 00:04:28,040
現在你知道它是什麼了
讓我們來實際設定

32
00:04:28,200 --> 00:04:33,600
順帶一提，這個功能還是非常實驗性的
首先我們需要在 settings.json 檔案裡啟用它

33
00:04:33,700 --> 00:04:44,860
我們已經開了一個 Claude Code 實例
進入 settings.json 檔案
把 Claude Code Experimental Agent Teams 設為 1
也就是 true

34
00:04:44,960 --> 00:04:52,400
然後我們需要重新啟動 Claude 實例
在重新啟動之前
先確認你的 Claude 是最新版本
跑一下 Claude update，確保版本在 2.1.32 以上

35
00:04:52,640 --> 00:04:59,166
否則你無法使用 Agent Teams
即使你已經在設定中加了那個旗標

36
00:04:59,266 --> 00:05:06,724
然後我們用 dangerously skip permissions 旗標來執行
因為我們不想逐一批准每個檔案變更

37
00:05:06,824 --> 00:05:15,480
當要實際啟動一個團隊時
我們可以明確告訴 Claude 我們要什麼
要一個研究代理、要一個寫手代理
或者就讓它自己決定，給它一個任務範圍

38
00:05:15,600 --> 00:05:21,439
在這個階段
你必須明確告訴它你要一個 Agent Teams
或至少在提示詞中暗示

39
00:05:21,539 --> 00:05:29,624
我走過了幾個不同的使用情境
想了解什麼時候該用整個 Agent Teams
什麼時候用子代理、什麼時候用單一代理

40
00:05:29,724 --> 00:05:37,360
我有一些商業使用案例和內容創作的例子
當我仔細想過後
覺得其實不太需要用 Agent Teams 來做這些

41
00:05:37,560 --> 00:05:44,279
然後有些情況變得更複雜、更交織
協作更重要
那就是六分或八分的 Agent Teams 使用情境

42
00:05:44,379 --> 00:05:51,682
一個二分的使用情境
基本上是建立一個 Agent Teams
從 Airtable 內容行事曆中提取想法

43
00:05:51,782 --> 00:06:00,400
它啟動四個隊友：
一個寫 LinkedIn 貼文、一個寫 Instagram 貼文
一個做深度研究
然後一個審稿員來檢查草稿

44
00:06:00,400 --> 00:06:10,871
這基本上就是一組上下文提示詞組合在一起
不太需要 LinkedIn 貼文寫手
跟 Instagram 貼文寫手之間的協作

45
00:06:10,971 --> 00:06:19,636
它們可能需要一些深度研究
但那能不能在一個單獨的步驟中完成
然後以子代理的方式傳給各個寫手？大概可以

46
00:06:19,736 --> 00:06:28,040
所以我把這歸類為二分的使用情境
而六分的使用情境，需要更多協作的
可以是從影片逐字稿重新利用內容

47
00:06:28,040 --> 00:06:43,467
我可以載入這支影片的逐字稿
隊友一寫一篇 Markdown 格式的長篇部落格文章
提取關鍵框架、針對 SEO 做結構化
確保可以上傳到 WordPress 或 Webflow

48
00:06:43,567 --> 00:06:49,443
隊友二專門負責 LinkedIn 輪播圖
生成圖片、鉤子和敘事角度

49
00:06:49,543 --> 00:06:53,400
隊友三負責撰寫
針對你的受眾量身定制的電子報

50
00:06:53,400 --> 00:07:03,415
這些都是相當獨立的任務
所以可以用子代理來跑
但這是六分而不是二分的使用情境
原因是你希望它們的產出保持一致

51
00:07:03,515 --> 00:07:10,387
因此隊友一、二、三很可能需要
在鉤子角度等方面協作
不完全重複但保持相似性

52
00:07:10,487 --> 00:07:19,520
它們還可以查看彼此的檔案
來建立長篇文章、LinkedIn 輪播圖腳本
以及電子報之間一致的訊息

53
00:07:19,600 --> 00:07:27,522
Agent Teams 真正發光的地方
我稱之為八分的使用情境
是建構更複雜的東西
你絕對需要協作的時候

54
00:07:27,622 --> 00:07:40,557
比如一個 Next.js 加 Stripe 的應用程式
隊友一建構 API 層，包含所有端點和 webhook
隊友二只做前端
專注在前端工作，不會有後端的上下文干擾

55
00:07:40,657 --> 00:07:42,920
隊友三負責撰寫完整的測試套件

56
00:07:43,120 --> 00:07:51,525
而且在建構 API 層和前端的過程中
它們會持續跟隊友三溝通
隊友三負責測試
然後把結果回饋到任務清單

57
00:07:51,625 --> 00:08:02,131
為了讓你看到這實際上怎麼運作
我們複製第二個使用情境
指定「create an agent team that」然後貼上內容

58
00:08:02,231 --> 00:08:09,760
現在它會理解
如果我們已經重新啟動實例
settings.json 裡有那個啟用團隊的旗標

59
00:08:09,920 --> 00:08:19,591
我們指定要一個 Agent Teams
它現在就會去建立那些個別的隊友
我們把影片的實際逐字稿放進去

60
00:08:19,691 --> 00:08:30,168
它會生成隊友
然後它們會互相溝通
在長篇文章、五張 LinkedIn 輪播圖腳本
以及電子報之間建立一致的訊息

61
00:08:30,268 --> 00:08:37,320
然後啟動那些個別的隊友
我們會看到所有隊友平行工作
而且可以在它們之間切換

62
00:08:37,320 --> 00:08:45,737
你可以使用 Shift 加上下方向鍵來指定隊友
單獨跟它們對話
並且單獨指派任務給特定隊友

63
00:08:45,837 --> 00:08:54,254
我們可以中斷特定的隊友，直接跟它們對話
這讓我們能在隊友互相協作的同時
也能控制和提供輸入

64
00:08:54,354 --> 00:09:05,120
如果你沒有安裝 Tmux 之類的工具
它們全部會出現在同一個終端機視窗裡

65
00:09:05,200 --> 00:09:10,215
如果你有安裝 Tmux，就會分成各自的視窗
這樣你就可以看到每個代理的上下文輸入
和它即時完成的工作

66
00:09:10,315 --> 00:09:20,161
它已經平行設定了三個內容隊友
部落格寫手隊友、輪播圖寫手隊友和電子報寫手
它給每個隊友一個個別的任務和輸出檔案

67
00:09:20,261 --> 00:09:29,920
現在它們要開始互動了
跨團隊協調已經內建好了
部落格寫手傳訊息給輪播圖寫手
告知它們的鉤子角度，這樣就不會重複

68
00:09:30,080 --> 00:09:39,983
電子報寫手檢查其他兩份草稿
來保持訊息一致，但採取不同的角度
三個都遵循相同的品牌語調、詞彙清單和人性化規則

69
00:09:40,083 --> 00:09:50,367
三個都完成後，會進入審查階段
標記任何矛盾、檢查品牌語調
確保每篇文章真正採取不同角度
而不只是同一個東西的縮短版

70
00:09:50,467 --> 00:09:55,800
這裡很棒的一點是
在同一個視窗裡可以看到所有正在進行的動作

71
00:09:55,800 --> 00:10:01,877
我們可以看到輪播圖寫手的動作
然後看到部落格的動作
這兩者是同時在平行運作的

72
00:10:01,977 --> 00:10:13,286
如果我們想在不同的視窗中查看它們
看每個代理的進度
只要 brew install Tmux 就行了
它能讓我們在不同的終端機視窗中查看代理

73
00:10:13,386 --> 00:10:19,800
但因為我們用的是標準的 VS Code 終端機
所以可以在同一個視窗裡看到全部

74
00:10:19,840 --> 00:10:31,880
如果我們想在隊友之間切換並給予特定指示
可以用 Shift 加上方向鍵
我們可以看到在 Team Lead、部落格寫手
輪播圖寫手、電子報寫手之間切換

75
00:10:31,980 --> 00:10:41,513
如果我們想給它們特定資訊
比如 Team Lead，按 Enter
然後跟 Team Lead 對話並給予那些特定指示

76
00:10:41,613 --> 00:10:47,800
我們當然也可以中斷它們的工作階段
但重點是我們仍然可以控制
正在平行運作的團隊

77
00:10:47,800 --> 00:10:58,042
這很重要
因為跑子代理時，通常只能跟 Team Lead 對話
但跑 Agent Teams 時
我們可以直接跟個別團隊成員對話

78
00:10:58,142 --> 00:11:09,895
所以就是在 settings.json 中改一個設定
加上一個提示詞
你就有了一個協調好的 AI Agent Teams
在平行運作，而且彼此溝通

79
00:11:09,995 --> 00:11:15,200
但重要的是要了解
哪些任務適合用團隊
哪些應該只用子代理或單一代理

80
00:11:15,200 --> 00:11:25,318
現在讓我們快速談談
使用團隊方式的一些潛在限制
首先是沒有上下文繼承
被啟動的隊友不會獲得主工作流程的對話歷史

81
00:11:25,418 --> 00:11:31,450
所以我們需要確保 Claude
傳給它們足夠多的上下文來完成工作

82
00:11:31,550 --> 00:11:38,360
權限是會傳遞的
如果我們一開始就開啟了跳過權限
那這個設定會傳遞給所有隊友

83
00:11:38,360 --> 00:11:44,773
假設我們有一個審稿代理
不希望它實際去編輯檔案
我們就需要特別要求修改它的權限

84
00:11:44,873 --> 00:11:57,007
當然，隊友之間的跨團隊協作
意味著我們會花費更多 token
更多代理等於更多 token
所以只在任務真正需要的時候才用 Agent Teams

85
00:11:57,107 --> 00:12:04,560
如果它們各自處理不同的檔案，那沒問題
但如果有跨團隊協作在同一個檔案上
它們可能會互相覆寫

86
00:12:04,560 --> 00:12:13,805
所以你需要確保它們有適當的分工
那問題來了
什麼時候該用 Agent Teams、子代理
還是單一代理？

87
00:12:13,905 --> 00:12:22,961
我以後的做法是這樣的
對於簡單的任務
只有一個檔案或幾個上下文檔案
一個功能、一段對話，我會用單一代理

88
00:12:23,061 --> 00:12:26,080
我也可以讓這個單一代理啟動子代理

89
00:12:26,320 --> 00:12:37,401
如果我需要專家
而且上下文對單一代理來說太大了
我會擴展到子代理
來提升品質並降低成本
就像之前研究員、寫手和審稿員的例子

90
00:12:37,501 --> 00:12:50,720
但當我需要更複雜的任務
比如建構一個 SaaS 應用程式
需要速度和協調
平行任務且代理之間需要互相溝通時
那我就會使用 Agent Teams

91
00:12:50,720 --> 00:12:58,054
簡單來說，從簡單開始
隨著專案變複雜時升級到子代理
當任務真正需要跨團隊協作時
才使用 Agent Teams

92
00:12:58,154 --> 00:13:03,937
如果你還沒看過我原本的 Claude Code 影片
先去看那個，我把連結放在上面了

93
00:13:04,037 --> 00:13:12,640
如果你想深入了解
如何用這些工具建構正式環境的系統
可以看看我的 AI Automation Academy
連結在下方說明欄裡

