1
00:00:00,080 --> 00:00:05,200
三天前，我發了一支影片
介紹 Claude Code 的各個層級，反響很大

2
00:00:05,200 --> 00:00:09,600
但我遺漏了一個關鍵的東西
如果你要正確使用它，你必須了解

3
00:00:09,600 --> 00:00:12,400
那就是Agent Teams

4
00:00:12,400 --> 00:00:16,800
從那之後，我深入研究了官方文件
也親自動手測試過了

5
00:00:16,800 --> 00:00:21,200
一旦搞懂這個概念
它徹底改變了我對使用 Claude Code 的想法

6
00:00:21,200 --> 00:00:24,400
因為如果你跟大多數人一樣
只用單一代理來跑

7
00:00:24,400 --> 00:00:27,040
你可能也注意到了跟我一樣的問題
跑越久，表現越差

8
00:00:27,040 --> 00:00:32,400
它會遺忘上下文、引入 bug
還會逼你不斷重複自己說過的話

9
00:00:32,400 --> 00:00:37,600
所以在這支影片裡
我會拆解 Claude 的Agent Teams到底是什麼

10
00:00:37,600 --> 00:00:41,800
為什麼它們存在，以及什麼時候該用Agent Teams
而不是子代理或單一代理

11
00:00:41,800 --> 00:00:44,800
這樣你就能更快地
建構出可靠的系統

12
00:00:44,800 --> 00:00:46,400
那我們直接開始吧

13
00:00:46,400 --> 00:00:53,360
你塞進單一代理上下文視窗的資訊越多
它的表現就越差

14
00:00:53,360 --> 00:00:58,400
模型就越難專注在
當下真正重要的事情上

15
00:00:58,400 --> 00:01:03,200
當這個小小的上下文進度條逐漸填滿
你就會遇到上下文劣化的問題

16
00:01:03,200 --> 00:01:08,400
當它到達大約 95% 的時候
它會壓縮並摘要重要資訊

17
00:01:08,400 --> 00:01:13,600
接下來的對話只會使用這些摘要
意思是它最終再也找不到

18
00:01:13,600 --> 00:01:18,800
你在幾千個 token 之前
給它的那些關鍵細節了

19
00:01:18,800 --> 00:01:23,200
現在想像一下在更大的專案中
這會造成多大的損害

20
00:01:23,200 --> 00:01:27,600
在那種專案中，所有關鍵細節都很重要
而不只是讓 Claude Code 執行一個獨立任務

21
00:01:27,600 --> 00:01:32,400
所以單一代理會不堪負荷、會遺忘
而社群中的專家們很早就發現了這個問題

22
00:01:32,400 --> 00:01:36,800
他們開始自己建構子代理系統

23
00:01:36,800 --> 00:01:43,360
你使用子代理基本上只有兩個原因
第一個是提升輸出品質

24
00:01:43,360 --> 00:01:48,800
可以把它想成是雇用專家
而不是雇用通才

25
00:01:48,800 --> 00:01:54,400
我們可以讓一個 Claude 去委派任務
給同一個工作階段中專注且專業化的實例

26
00:01:54,400 --> 00:01:58,800
這些實例有自己的上下文視窗
因此我們可以提升輸出品質

27
00:01:58,800 --> 00:02:03,200
同時也能降低成本
因為我們不需要把所有上下文都餵給子代理

28
00:02:03,200 --> 00:02:07,200
第二個原因是加快完成速度

29
00:02:07,200 --> 00:02:10,240
不是讓它們來回傳遞資訊
而是讓它們平行處理

30
00:02:10,240 --> 00:02:15,600
開兩個終端機視窗
分別處理互不相依的任務

31
00:02:15,600 --> 00:02:20,400
比如說，終端機一可以讓它
撰寫 LinkedIn 貼文

32
00:02:20,400 --> 00:02:25,200
終端機二同時平行處理
Instagram 貼文，這兩者通常是不相關的

33
00:02:25,200 --> 00:02:33,840
所以像 Boris Cherny，也就是 Claude Code 的
創造者，以及社群中的其他進階使用者

34
00:02:33,840 --> 00:02:38,800
他們透過自己建構子代理系統
來解決這個問題

35
00:02:38,800 --> 00:02:44,400
Boris 甚至說他同時跑了多達 15 個代理
在終端機裡平行跑 5 個

36
00:02:44,400 --> 00:02:49,600
然後同時在線上跑 5 到 10 個 Claude

37
00:02:49,600 --> 00:02:54,400
這在理論上很棒
但當代理們實際需要互相溝通時就崩潰了

38
00:02:54,400 --> 00:02:58,800
因為子代理只能回報給父代理

39
00:02:58,800 --> 00:03:01,920
它們之間無法直接溝通

40
00:03:01,920 --> 00:03:08,400
舉例來說，假設我們有一個內容研究團隊
研究員是子代理一

41
00:03:08,400 --> 00:03:13,600
寫手是我們的主要實例
審稿員是子代理二

42
00:03:13,600 --> 00:03:19,200
子代理，也就是研究員和審稿員
只能把資訊回傳給主要實例，也就是寫手

43
00:03:19,200 --> 00:03:24,400
審稿員無法審查研究內容
研究員也看不到審稿員的任何輸出

44
00:03:24,400 --> 00:03:27,600
寫手必須處理所有這些溝通

45
00:03:27,600 --> 00:03:30,200
所以用子代理的話
主代理最終會成為瓶頸

46
00:03:30,200 --> 00:03:36,800
主代理和每一個專業子代理之間
只有雙向溝通

47
00:03:36,800 --> 00:03:42,400
當我們啟動子代理時
每個子代理有自己的上下文

48
00:03:42,400 --> 00:03:47,600
結果會回傳給主代理
在我們的例子中就是寫手

49
00:03:47,600 --> 00:03:52,400
而審稿員和研究員作為子代理
主代理負責協調所有的工作

50
00:03:52,400 --> 00:03:58,800
所以當多個任務和多個子代理
都回傳給主代理時，它顯然就成了瓶頸

51
00:03:58,800 --> 00:04:03,600
而且這只在你不需要
研究員和審稿員互相溝通時才行得通

52
00:04:03,600 --> 00:04:08,400
所以子代理就像一個
中心輻射模型，給了我們委派能力

53
00:04:08,400 --> 00:04:12,800
但沒有給我們協作能力

54
00:04:12,800 --> 00:04:18,400
而這正是Agent Teams填補的缺口
它們透過共享任務清單來做到這一點

55
00:04:18,400 --> 00:04:24,000
主代理會決定並啟動隊友
基本上就是我們的子代理

56
00:04:24,000 --> 00:04:29,600
但不同的是，它們有這個共享任務清單
能夠與每一個隊友來回溝通

57
00:04:29,600 --> 00:04:34,800
不只如此，隊友之間
也能互相溝通

58
00:04:34,800 --> 00:04:40,000
把它想成子代理的架構
但多了不只能跟主代理溝通的能力

59
00:04:40,000 --> 00:04:46,400
還能從共享任務清單中領取任務
並且彼此之間互相溝通

60
00:04:46,400 --> 00:04:52,000
所以它們一樣有自己的上下文視窗
但不是把所有資訊都回傳給主代理

61
00:04:52,000 --> 00:04:56,400
而是被設定為獨立的 Claude Code 實例

62
00:04:56,400 --> 00:05:00,800
這樣做有個缺點
它們能存取主代理所有能存取的東西

63
00:05:00,800 --> 00:05:05,200
包括 Claude.md 檔案、MCP 工具等等

64
00:05:05,200 --> 00:05:10,400
但代價是我們必須把這些全部放進
每一個子代理或隊友的上下文中

65
00:05:10,400 --> 00:05:14,800
所以最終會花費更多的 token

66
00:05:14,800 --> 00:05:18,400
好，現在你知道它是什麼了
讓我們來實際設定它

67
00:05:18,400 --> 00:05:22,800
順帶一提，這個功能目前還是非常實驗性的

68
00:05:22,800 --> 00:05:28,200
首先我們需要做一件事
就是在 settings.json 檔案中啟用它

69
00:05:28,200 --> 00:05:34,400
這裡我們已經開了一個 Claude Code 實例
我們要跳到 settings.json 檔案

70
00:05:34,400 --> 00:05:40,800
把 Claude Code 的實驗性Agent Teams設為 true

71
00:05:40,800 --> 00:05:44,800
然後我們需要確保重新啟動 Claude 實例

72
00:05:44,800 --> 00:05:49,200
在重啟之前，先確認我們有最新版本的 Claude
執行 Claude update

73
00:05:49,200 --> 00:05:52,640
確保版本在 2.1.32 以上
否則你無法使用Agent Teams

74
00:05:52,640 --> 00:05:56,800
即使你已經在設定中開啟了那個旗標

75
00:05:56,800 --> 00:06:02,400
然後我們要加上
dangerously skip permissions 旗標來執行

76
00:06:02,400 --> 00:06:06,800
因為我們不想要每一次檔案變更
都需要手動核准

77
00:06:06,800 --> 00:06:12,400
在實際生成團隊的時候
我們可以明確告訴 Claude 我們想要什麼

78
00:06:12,400 --> 00:06:15,480
比如說我要一個研究代理、一個寫手代理
或者就讓它自己決定，給它一個任務範圍

79
00:06:15,600 --> 00:06:20,800
在這個時候，你必須明確告訴它
你想要一個 Agent Team

80
00:06:20,800 --> 00:06:24,800
或者至少在你的提示詞中暗示這一點

81
00:06:24,800 --> 00:06:30,400
我試了幾個不同的使用情境
來理解什麼時候該用完整的Agent Teams

82
00:06:30,400 --> 00:06:33,600
什麼時候用子代理
什麼時候用單一代理

83
00:06:33,600 --> 00:06:37,560
我有幾個範例
包括商業用途和內容創作

84
00:06:37,560 --> 00:06:42,800
有些情境我覺得
其實不太需要用到Agent Teams

85
00:06:42,800 --> 00:06:48,400
而當任務變得更複雜、更相互交織
協作更重要的時候

86
00:06:48,400 --> 00:06:53,400
那就是滿分十分中六分或八分的使用情境
適合用Agent Teams

87
00:06:53,400 --> 00:07:00,400
十分中二分的使用情境基本上是
建立一個 Agent Team 從 Airtable 內容日曆抓取點子

88
00:07:00,400 --> 00:07:05,200
生成四個隊友，一個寫 LinkedIn 貼文
一個寫 Instagram 貼文

89
00:07:05,200 --> 00:07:09,200
另一個做深度研究
還有一個審稿員檢查草稿

90
00:07:09,200 --> 00:07:14,800
這基本上就是一組上下文提示詞的組合
不需要太多協作

91
00:07:14,800 --> 00:07:19,600
LinkedIn 貼文的寫手不一定需要
跟 Instagram 貼文的寫手溝通

92
00:07:19,600 --> 00:07:24,400
它們可能需要一些深度研究
但那其實可以在單獨的步驟中完成

93
00:07:24,400 --> 00:07:28,040
然後再傳給各個寫手作為子代理
所以我認為這只是十分中二分的使用情境

94
00:07:28,040 --> 00:07:33,200
十分中六分的使用情境
有更多的協作需求

95
00:07:33,200 --> 00:07:37,600
可以是從影片逐字稿做內容改編

96
00:07:37,600 --> 00:07:42,800
我可以載入這支影片的逐字稿
隊友一撰寫 Markdown 格式的長篇部落格文章

97
00:07:42,800 --> 00:07:47,600
提取關鍵框架、針對 SEO 做結構化
確保可以上傳到 WordPress 或 Webflow

98
00:07:47,600 --> 00:07:53,400
隊友二負責 LinkedIn 輪播圖
生成圖片、撰寫吸睛標題和故事角度

99
00:07:53,400 --> 00:07:58,800
隊友三負責撰寫
針對你的受眾量身打造的電子報

100
00:07:58,800 --> 00:08:03,200
這些都是相當獨立的任務
所以可以用子代理來跑

101
00:08:03,200 --> 00:08:08,400
但這之所以是十分中六分的使用情境
而不是二分，是因為你希望它們的輸出一致

102
00:08:08,400 --> 00:08:13,600
所以隊友一、二、三可能需要
在吸睛標題的角度等方面進行協作

103
00:08:13,600 --> 00:08:19,520
這樣就不會完全重複
但能保持相似性

104
00:08:19,600 --> 00:08:24,400
它們也可以檢查彼此的檔案
以確保所有素材的訊息一致

105
00:08:24,400 --> 00:08:30,400
而Agent Teams真正發光的地方
是我所說的十分中八分的使用情境

106
00:08:30,400 --> 00:08:35,200
就是建構更複雜的東西
絕對需要協作的場景

107
00:08:35,200 --> 00:08:39,600
比如用 Next.js 搭配 Stripe 開發應用程式

108
00:08:39,600 --> 00:08:42,920
隊友一負責建構 API 層
包含所有端點和 webhook

109
00:08:43,120 --> 00:08:48,400
隊友二只負責前端
專注在前端的東西

110
00:08:48,400 --> 00:08:52,800
不需要把後端的上下文塞進去
隊友三負責撰寫完整的測試套件

111
00:08:52,800 --> 00:08:58,400
在建構 API 層和前端的過程中
它們會不斷跟隊友三溝通

112
00:08:58,400 --> 00:09:02,400
隊友三負責測試
然後把結果回饋到任務清單中

113
00:09:02,400 --> 00:09:09,760
讓你看看實際運作的樣子
我們要複製這第二個使用情境

114
00:09:09,760 --> 00:09:14,400
我們只要指定「建立一個 Agent Team 來」
然後貼上內容

115
00:09:14,400 --> 00:09:19,600
現在如果我們已經重啟實例
而且 settings.json 中的旗標有開啟

116
00:09:19,600 --> 00:09:24,800
它就會理解我們想用團隊模式
然後實際去建立那些個別的隊友

117
00:09:24,800 --> 00:09:28,800
我們要把影片的逐字稿丟進去

118
00:09:28,800 --> 00:09:33,600
它會生成隊友
然後它們會互相協作

119
00:09:33,600 --> 00:09:37,320
來建立長篇文章、五張 LinkedIn 輪播圖腳本
以及電子報之間一致的訊息

120
00:09:37,320 --> 00:09:42,800
然後啟動那些個別的隊友
我們會看到所有隊友平行運作

121
00:09:42,800 --> 00:09:47,200
而且我們可以在它們之間切換

122
00:09:47,200 --> 00:09:52,800
你可以使用 Shift 加上方向鍵上和下
來指定隊友，單獨跟特定隊友對話

123
00:09:52,800 --> 00:09:57,600
並且單獨指派任務給特定隊友

124
00:09:57,600 --> 00:10:01,600
我們可以中斷特定隊友
也可以直接跟它們對話

125
00:10:01,600 --> 00:10:05,120
這讓我們可以運行一個 Agent Team
它們之間互相協作

126
00:10:05,120 --> 00:10:08,800
但我們也能控制並提供輸入

127
00:10:08,800 --> 00:10:14,400
除非你有安裝 Tmux
否則它們都會顯示在同一個終端機視窗中

128
00:10:14,400 --> 00:10:19,800
如果你有安裝 Tmux
它就會分割成個別的視窗

129
00:10:19,800 --> 00:10:25,200
這樣你就能看到每個代理
被輸入的上下文以及即時完成的工作

130
00:10:25,200 --> 00:10:29,920
它已經設定好三個內容隊友平行運作了

131
00:10:29,920 --> 00:10:34,800
你有部落格寫手隊友、輪播圖寫手隊友
和電子報寫手

132
00:10:34,800 --> 00:10:39,200
它給每個隊友一個獨立的任務
和一個要完成的輸出檔案

133
00:10:39,200 --> 00:10:43,600
然後它們就會開始互相溝通
已經內建了跨團隊協調

134
00:10:43,600 --> 00:10:48,800
部落格寫手會把吸睛標題的角度
傳給輪播圖寫手，避免重複

135
00:10:48,800 --> 00:10:55,800
電子報寫手會檢查另外兩個草稿
以保持訊息一致，但採用不同的角度

136
00:10:55,800 --> 00:11:01,200
三個隊友都遵循相同的品牌語調、
禁用詞清單、人性化規則，不用破折號

137
00:11:01,200 --> 00:11:06,400
三個都完成後，會進入審查階段
標記任何矛盾之處

138
00:11:06,400 --> 00:11:11,200
檢查品牌語調，確保每篇內容
都真正採用不同角度

139
00:11:11,200 --> 00:11:15,200
而不只是同一篇內容的縮短版

140
00:11:15,200 --> 00:11:19,800
很棒的是，在同一個視窗中
可以看到所有正在進行的動作

141
00:11:19,800 --> 00:11:24,400
我們可以看到輪播圖寫手的動作
也能看到部落格寫手的動作

142
00:11:24,400 --> 00:11:28,800
這兩者是同時在平行運作的

143
00:11:28,800 --> 00:11:34,400
如果我們想在不同視窗中
查看它們各自的進度

144
00:11:34,400 --> 00:11:39,800
就用 brew install 安裝一個叫做 Tmux 的服務
讓我們能在不同的終端機視窗中看到代理

145
00:11:39,800 --> 00:11:43,800
但因為我們用的是標準的 VS Code 終端機
所以全部都在同一個視窗中

146
00:11:43,800 --> 00:11:47,800
如果我們想在隊友之間切換
並給予特定指示

147
00:11:47,800 --> 00:11:52,400
可以用 Shift 加上方向鍵上
就能看到我們在Team Lead之間切換

148
00:11:52,400 --> 00:11:57,200
部落格寫手、輪播圖寫手、
電子報寫手等等

149
00:11:57,200 --> 00:12:02,400
如果我們想給它們特定的資訊
比如給Team Lead，就按 Enter

150
00:12:02,400 --> 00:12:06,400
然後跟Team Lead對話
給予那些特定的指示

151
00:12:06,400 --> 00:12:10,800
當然我們也可以中斷它們的工作階段
但重點是我們仍然能控制平行運作的團隊

152
00:12:10,800 --> 00:12:15,200
這很重要，因為當我們使用子代理時
通常是跟Team Lead溝通

153
00:12:15,200 --> 00:12:20,400
而使用Agent Teams時
我們可以直接跟個別的團隊成員對話

154
00:12:20,400 --> 00:12:26,400
所以就是在 settings.json 中改一個設定
加上一個提示詞

155
00:12:26,400 --> 00:12:31,200
你就有了一個協調好的 AI Agent Team
在平行運作，而且彼此溝通

156
00:12:31,200 --> 00:12:36,800
但重要的是要了解
哪些任務適合用團隊

157
00:12:36,800 --> 00:12:40,800
哪些應該只用子代理或單一代理

158
00:12:40,800 --> 00:12:46,400
現在讓我們快速談談
使用團隊方式的一些潛在限制

159
00:12:46,400 --> 00:12:50,800
首先是沒有上下文繼承
被啟動的隊友不會獲得主工作流程的對話歷史

160
00:12:50,800 --> 00:12:56,400
所以我們需要確保 Claude
傳給它們足夠多的上下文來完成工作

161
00:12:56,400 --> 00:13:00,800
權限是會傳遞的
如果我們一開始就開啟了跳過權限

162
00:13:00,800 --> 00:13:04,560
那這個設定會傳遞給所有隊友

163
00:13:04,560 --> 00:13:09,600
假設我們有一個審稿代理
不希望它實際去編輯檔案

164
00:13:09,600 --> 00:13:13,200
我們就需要特別要求修改它的權限

165
00:13:13,200 --> 00:13:18,400
當然，隊友之間的跨團隊協作
意味著我們會花費更多 token

166
00:13:18,400 --> 00:13:22,800
更多代理等於更多 token
所以只在任務真正需要的時候才用

167
00:13:22,800 --> 00:13:27,200
當任務複雜度達到十分中七分或八分
確實需要Agent Teams的時候才用

168
00:13:27,200 --> 00:13:32,400
如果它們各自處理不同的檔案，那沒問題
但如果有跨團隊協作在同一個檔案上

169
00:13:32,400 --> 00:13:36,800
它們可能會互相覆寫
所以你需要確保有適當的分工

170
00:13:36,800 --> 00:13:41,600
那問題來了
什麼時候該用Agent Teams、子代理、還是單一代理？

171
00:13:41,600 --> 00:13:46,800
我以後的做法是這樣的
對於簡單的任務

172
00:13:46,800 --> 00:13:50,800
只有一個檔案或幾個上下文檔案
一個功能、一段對話

173
00:13:50,800 --> 00:13:54,400
我會用單一代理
我也可以讓這個單一代理啟動子代理

174
00:13:54,400 --> 00:13:59,600
如果我需要專家
而且上下文對單一代理來說太大了

175
00:13:59,600 --> 00:14:04,400
我會擴展到子代理
來提升品質並降低成本

176
00:14:04,400 --> 00:14:08,800
就像之前研究員、寫手和審稿員的例子

177
00:14:08,800 --> 00:14:14,400
但當我需要更複雜的任務
比如建構一個 SaaS 應用程式

178
00:14:14,400 --> 00:14:19,200
需要速度和協調
平行任務且代理之間需要互相溝通時

179
00:14:19,200 --> 00:14:22,800
那我就會使用Agent Teams

180
00:14:22,800 --> 00:14:27,200
簡單來說，從簡單開始
隨著專案變複雜時升級到子代理

181
00:14:27,200 --> 00:14:32,400
當任務真正需要跨團隊協作時
才使用Agent Teams

182
00:14:32,400 --> 00:14:37,200
如果你還沒看過我原本的 Claude Code 影片
先去看那個，我把連結放在上面了

183
00:14:37,200 --> 00:14:42,400
如果你想深入了解如何用這些工具
建構正式環境的系統

184
00:14:42,400 --> 00:14:46,800
可以看看我的 AI Automation Academy
連結在下方說明欄裡
