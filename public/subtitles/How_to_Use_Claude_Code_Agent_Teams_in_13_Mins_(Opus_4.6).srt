1
00:00:00,080 --> 00:00:27,040
Three days ago, I released a video showing every level of Claude code, and it took off.But I left out something critical that you need to understand if you're going to use it properly, and that's agent teams.Since then, I've dug deep into the official docs and been hands-on testing, and once this clicked, it completely changed how I thought about using Claude code for my projects.Because if you're running it the way most people are, as a single agent, you've probably noticed the same thing that I have.The longer it runs, the worse it gets.

2
00:00:27,040 --> 00:00:53,360
It's for getting context, introducing bugs, andforcing you to repeat yourself.So in this video, I'll break down what Claude's agent teams actually are, why they exist, and when to use them versus sub agents or single agents so that you can build reliable systems faster.So let's get straight into it.More information you staff into a single agent's context window, the worse it performs, the harder it is for the model to focus on what actually matters right now.

3
00:00:53,360 --> 00:01:18,800
As this little context bar fills up, you get context raw, and when it gets around 95%, it compresses andsummarizes important information.And the next section of the conversation uses the summaries only, meaning ultimately it can no longer find the key details that you gave to it thousands of tokens ago.Now imagine the damage this can cause on a much larger project where all of the key details matter and not just getting claw code to do an isolated task.

4
00:01:18,800 --> 00:01:43,360
So single agents get overwhelmed, they forget, and actually experts in the community spotted this problem early and they started building out their own sub agents.So you'd only use sub agents for two reasons withThe first is to improve output quality.So think hiring a specialist versus hiring a generist.We can have one Claude that's just delegating to focused specialized instances in the same session that have their own context window.

5
00:01:43,360 --> 00:02:10,240
And therefore we can improve the output quality and also reduce the cost because we're not feeding in all of the context to those specialized sub-agents.And the second reason is to get things done faster.So instead of having them feeding back and forth between each other, we would have them in parallel, two terminal windows open, taking on non-dependent tasks.Like for example, in terminal one, we could have it right in our LinkedIn posts.In terminal two, at the same time in parallel, we could have it working on Instagram posts, which are often unrelated.

6
00:02:10,240 --> 00:02:33,840
So people like Boris Cherny, the creator of Claude Code, and other power users in the community, they were tackling this by building their own sub-agent system.So Boris even said he ran up to 15 agents, so five in parallel in his terminal, and then five to 10 clauds online at the same time.And this is great in theory, but it broke down when the agents actually had to communicatecommunicate with each other.So sub-agents can only report back to the parent.

7
00:02:33,840 --> 00:03:01,920
So if, for example, we had a content research team with a researcher as sub-agent one, the writer is our main instance here, and the reviewer is sub-agent two, the sub-agents, the researcher and the reviewer can only feed information back to the main instance, the writer.The reviewer can't review the research, and the researcher can't see any outputs of the reviewer.The writer handles that all.So with sub-agents, what you actually end up with is the main agent becoming the bottleneck here.There's only two-way communication between that main agent andevery single specialist sub-agent.

8
00:03:01,920 --> 00:03:29,960
So when we were spinning up sub-agents, each sub-agent has its own context, and the results are therefore returned to our main agent.So in our case, the writer, and we'd have the reviewer and the researcher as sub-agents there.But the main agent is coordinating all of that work.So if multiple tasks and multiple sub-agents feed into that main agent, that becomes the clear bottleneck.And this only works if you don't need the researcher to interact with the reviewer and vice versa.So sub-agents acted like a hub-and-spoke model, and they gave us delegate

9
00:03:30,200 --> 00:03:59,960
but they didn't give us collaboration.And that's the gap that the agent teams actually fills.And they do this through a shared task list.The main agent will decide and spin up the teammates or effectively our sub-agents here.But the difference is they have this shared task list, which is able to communicate back and forth with every single teammate.And not only that, the teammates are able to actually communicate with one another.So think of it as a sub-agent structure, but with the ability to not only communicate with our main agent, but also bring tasks down from the shared

10
00:04:00,040 --> 00:04:28,040
task list and communicate with each other.So again, they have their own context window, but actually, instead of returning all the information to the main agent, they are set up as their own Claude code instances.Now this comes with drawbacks.They have access to everything that the main agent has access to, the Claude.md file, the MCPs, etc.But it comes at the expense that we have to put that all in the context of every single sub-agent or teammate that we spin up.So it ends up costing more in tokens.So now you know what it is.Let's actually set this up.

11
00:04:28,200 --> 00:04:52,400
And by the way, it's still very experimental.There's one thing we need to do first, and that's to enable it in our settings.json file.So we have a Claude code instance already open here.We're going to jump to our settings.json file, and we're going to replace that with Claude code experimental agent teams as one, which is true.And then we're going to need to make sure that we restart our Claude instance.Before we restart our Claude instance, we're just going to make sure that we have the latest version of Claude.So we're going to run Claude update.

12
00:04:52,640 --> 00:05:15,480
It's going to make sure that we're past 2.1.32, otherwise you will not be able to use the agent teams, even if you've got the flag in the settings.And then we're going to run itwith the flag dangerously skip permissions because we don't want to approve every single file change that's going to be made.Now, when it comes to actually spawning a team, we can either tell Claude exactly what we want.We want a research agent, we want a writer agent, or just let it decide and give it a task scope.

13
00:05:15,600 --> 00:05:37,360
You have to specifically at this point, tell it you want an agent team or allude to that in your prompt at least.Now, I walked through a few different use cases to try and understand where I'd use an entire agent team versus sub-agents versus single agents, and I've got a few examplesbusiness use cases, content creation, that are examples where I was like, actually, when it comes down to it, I probably wouldn't use the agent teams for this.

14
00:05:37,560 --> 00:06:00,400
And then cases where it gets more complex and more intertwined, where the collaboration is more important, which would be our six out of 10 or eight out of 10 use cases for using agent teams.So a two out of 10 use case would be effectively creating an agent team which pulls ideas from an Airtable content calendar.It spawns four teammates, one to write LinkedIn posts, one to write Instagram posts, another to do some deep research, and then a star review to check thedrafts.

15
00:06:00,400 --> 00:06:28,040
Now, that is something that's effectively a set of context prompts pulled together and does not require much collaboration between the LinkedIn post writer doesn't need to necessarily communicate with the Instagram post writer.They possibly need to get some deep research, but actually, could that be done in one separate step and actually passed into each of the individual writers as sub-agents?Probably.So that's why I deemed this a two out of 10 use case.A six out of 10 use case where there's increased amounts of collaboration could be content repurposing from a video transcript.

16
00:06:28,040 --> 00:06:53,400
So I could load in the transcript for this video,Teammate 1 is writing a long form blog post as Markdown.So it pulls out key frameworks, structures it for SEO, make sure that we can actually upload that to WordPress or Webflow, wherever we have our site.We have Teammate 2, which is all about LinkedIn carousels and actually generating images, the hook and the storytelling angle for carousels.And then Teammate 3, which might be writing an e-mail newsletter tailored for your audience.

17
00:06:53,400 --> 00:07:19,520
So all of those are quite individual tasks, so those could be run as sub-agents, but the reason this is a six out of 10 use case, insteadof a two out of 10 use case is because actually you want them to be consistent in their output.So therefore teammates one, two, and three would likely need to collaborate on things like what the angle on the hook so that we can actually not duplicate it exactly, but share similarities for that.But they can also check each other's files to keep consistent messaging across the assets there.

18
00:07:19,600 --> 00:07:42,920
And where agent teams really shine, what I call the eight out of 10 use case is building something more complex where you definitely need collaboration.So a Next.js application with StripeTeammate 1 is going to build the API layer with all the endpoints and webhooks.Teammate 2 is going to build just the front end, so they're going to specialize in front end stuff and not have any of the context of the back end feeding in.And Teammate 3 is going to write a full testing suite.

19
00:07:43,120 --> 00:08:09,760
And actually, throughout the builds of the API layer on the front end, they're going to be constantly talking to Teammate 3, who's going to be doing the testing, and then feeding that back up into the task list.Just so you can see exactly how this runs, we're going to copy this second use case here, and we're just going to specify, create anagent team that, and then we're going to paste in that there.And now it's going to understand if we've restarted our instance in the settings.json, we've got that flag on that says we want to use teams.

20
00:08:09,920 --> 00:08:37,320
We specified we want an agent team, and it's actually going to now go out and create those individual teammates.We're going to drop in the actual transcript from the video.It's going to generate the teammates, and then those are going to interact with each other to create consistent messaging across the long-form article, the five-part LinkedIn carousel script, and also the e-mail newsletter.and then spin up those individual teammates.We're going to see all those individual teammates working in parallel, and we're going to be able to flick through those.

21
00:08:37,320 --> 00:09:05,120
And you can actually talk individually and assign tasks individually to a specific teammate using shift up and shift down to specify the teammates.We can interrupt specific teammates.We can talk to them directly.And this enables us to actually run an agent team where they're collaborating with each other, but we can also control and have inputs too.Now, unless you have something like Tmux installed, they're all going to appear in thissingle terminal window.If you have Tmux installed, it's going to split out into individual windows.

22
00:09:05,200 --> 00:09:29,920
So you can see each agent's context being fed in and the work that it completes at the time.So it's set up the three content teammates in parallel.You've got a blog writer teammate, a carousel writer teammate, and a newsletter writer.It gives it an individual task.It gives it an output file that it's going to complete.And then now they're going to interact with each other.So it's got cross coordination built in already.The blog writer messages the carousel writer with their hook angle so they don't duplicate.

23
00:09:30,080 --> 00:09:55,800
letter writer checks on the other two drafts to keep messaging consistent, but takes a different angle, and all three follow the same brand voice, band word list, humanizer rules, and no em dashes.And once all three finish, it'll be run through the review stage to flag any contradictions, check brand voice, and make sure each piece genuinely takes a different angle rather than just being a shortened version of the same thing.Now, the great thing here is actually it has in the same window all of the actions that are taking place.

24
00:09:55,800 --> 00:10:19,800
So we've got the actions, for example, of the carousel writer here, then we can see the actions of the blogand both of these are being run simultaneously at the same time.Now, if we wanted to actually view these in separate windows and see their progression as individual agents, then we would just brew install a service called Tmux, which will allow us to actually see the agents on different terminal windows here.But because we're using the standard VS Code terminal, we can see them all in the same window.

25
00:10:19,840 --> 00:10:47,800
Now, if we want to shift between the teammates and give specific instructions, then we can use shift and press up, and we can see that we're switching between the team lead, the blog writer, the carousel writer,the newsletter writer, et cetera, as well.So if we wanted to actually give them specific information, like the team lead, we would hit enter, and then we would talk to the team lead and give those specific instructions.We can, of course, interrupt their sessions as well, but the idea is we still have control over the team that's running in parallel.

26
00:10:47,800 --> 00:11:15,200
And that's important because when we're running sub-agents, we generally talk to the team lead.When we're running teams of agents, we can actually directly talk to an individual team member.So literally one setting in our JSON.settings, one prompt, and you've got a coordinated team of AI agents working in parallel, and they're all communicating with each other.But the important thing is to understand which tasks actually are suitable for a team and which should just be using sub agents or single agents.

27
00:11:15,200 --> 00:11:38,360
Now let's quickly talk about some of the potential limitations of using this team approach.Now first is no context inheritance.So teammatesspun out, don't get that conversation history from your main workflow.So we need to actually make sure that Claude is passing them a generous amount of the contacts so that they can do their job.Permissions do propagate.So if we start with bypass permissions on, they will be passed to all otherof the teammates.

28
00:11:38,360 --> 00:12:04,560
So say we have a reviewer agent that we don't want to be actually editing, we're going to need to actually ask for to change the permissions of that.Of course, with the cross-collaboration between teammates, we're effectively spending more tokens.More agents equals more tokens.So only use it when the task is that 8 out of 10 or 7 out of 10 and actually deems an agent team necessary.And then of course, if they're working on individual files, it's okay.But if there's cross-collaboration in the same file, then they can actually overwrite each other.

29
00:12:04,560 --> 00:12:26,080
So you need to make sure they have that separation there.So the question isAnd when do I use agent teams versus sub-agents versus just a single agent anyway?The way that I'm going to treat this going forward is straightforward tasks where I have one file or a couple of context files, one feature, and one conversation.I'm going to use a single agent.And I can ask that single agent to spin out sub-agents too.

30
00:12:26,320 --> 00:12:50,720
If I need specialists and effectively my context is getting too large for a single agent conversation, I will expand that to sub-agents where we can improve the quality and reduce the cost for that level of quality.example of having a researcher, writer and reviewer.But when I need a more complex task like building out a SaaS application, for example, and I'm going to need speed and coordination where parallel tasks are taking place and agents need to talk to each other, then I'm going to use agent teams.

31
00:12:50,720 --> 00:13:12,640
So in simple, start simple, graduate sub-agents as the project gets more complex, and then reach for agent teams when the task genuinely needs that cross-collaboration.Now, if you haven't seen my original Claude Code video, go watch that first.I'll link it above.And if you want to go deeper on building production-readysystems with tools like this, check out my AI Automation Academy.The link's down in the description below.

