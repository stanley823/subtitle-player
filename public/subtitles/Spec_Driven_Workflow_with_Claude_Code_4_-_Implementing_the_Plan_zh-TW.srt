1
00:00:00,480 --> 00:00:28,880
好的，現在我們已經有了身份驗證表單的計畫文件，
這份計畫包含了實作所需的所有資訊、指令、程式碼範例和步驟。
所以下一步就是請 Claude Code 來完成這件事。
在我們開始之前，我想先談兩件事，從模型選擇開始。
到目前為止，我們一直使用的是 Sonnet 模型，
用來進行小幅的程式碼修改、建立規格，以及規劃功能，
因為我認為規劃模式預設也是使用 Sonnet 4.5。

2
00:00:29,280 --> 00:00:57,040
然而，在實作計畫時，我通常會把模型切換到 Opus 4.5，
或者是你觀看這部影片時當時最新的 Opus 模型。
這是因為 Opus 模型，尤其是 4.5 版本，根據我的經驗，
非常擅長遵循一套指令，就像計畫中所概述的那樣，而且它們很少偏離。
所以根據我正在開發的功能性質，
我有時會在這個時間點選擇使用 Opus 模型，只需輸入 model 指令即可。

3
00:00:57,640 --> 00:01:20,080
然後選擇 Opus 4.5 模型。
對於簡單的功能，就像我們即將實作的這個，我可能會繼續用 Sonnet，
但對於更深入、多步驟或複雜的功能，我很可能會切換。
好的，接下來，我想提到 Claude Code 中一個叫做延伸思考（extended thinking）的功能，
這是讓模型花更多時間思考任務的模式。

4
00:01:20,320 --> 00:01:47,080
同樣地，這個模式更適合更複雜的多步驟問題，
因為它給模型額外的空間來探索可能的解決方案、自我修正等等。
確實，因為內部推理的關係，它會消耗更多 token，
但當實作並不那麼直觀時，它帶來的回報是值得的。
這也意味著如果它發現計畫中有任何漏洞，它會找到替代解決方案。
現在，思考模式預設是開啟的，我想。

5
00:01:47,080 --> 00:01:59,520
說實話，除非我在做一些微不足道的變更，否則我大部分時間都保持開啟。
但你可以透過使用 Config 指令，
然後找到名為 Thinking Mode 的設定來開關它。

6
00:02:00,160 --> 00:02:26,720
你可以看到我目前已開啟它，
這意味著我目前傳送的所有提示，模型都會進行額外的推理，希望能產出更好的結果。
你可以在這裡按空白鍵或 Enter 來關閉它，
這個設定會儲存到你所有專案的全域使用者設定中。
我會繼續保持開啟，但要特別注意搭配 Opus 4.5 使用思考模式時，
因為它可能會更快消耗你的 token 限額。

7
00:02:26,800 --> 00:02:55,600
在 Mac 上，我也可以按 Option + T 快速開關思考模式，它會帶出開啟或關閉的選項。
在 Windows 上，我想你需要改按 Alt + T。
另外，如果你預設關閉了思考模式，
你可以在單次對話或提示中輸入 UltraThink 這個詞來觸發延伸思考。
我可以打出我的一般提示，然後在最後告訴它 UltraThink，
這樣就會為那個提示觸發思考模式。

8
00:02:56,000 --> 00:03:16,080
無論如何，我要為這個保持思考模式開啟，
我也已切換到 Opus 4.5，雖然對這個功能來說可能有點大材小用，
但我想展示我的典型工作流程。
現在我要確保計畫文件是開啟的，這樣它就會自動作為上下文提供給 Claude Code，
然後我輸入：「你能實作這個計畫嗎？」

9
00:03:17,400 --> 00:03:42,560
然後按下 Enter。
這樣做之後，模型會看過計畫，推理如何以最佳方式實作它，
然後開始進行程式碼變更。
通常，我也會同時開啟自動編輯模式，就讓我們這樣做吧。
為了加速這個過程，我要加速播放影片，授予它可能需要的任何權限，
然後等它完成後回來，這樣我們就能一起看結果。

10
00:03:50,640 --> 00:04:18,880
好的，建立所有那些元件總共花了兩分半鐘。
如果我們看一下這些內容，你可以看到它建立了所有這些新元件、更新了這些頁面，
並建立了所有新的測試檔案，它們現在全部通過了。
上面有某種錯誤，我認為是 linting 錯誤，它發現後就去修復了。
所以它確實在遇到問題時會反覆嘗試解決。
那麼現在讓我們來看看它新增的檔案。

11
00:04:19,279 --> 00:04:47,000
只是非常簡短地看一下，同樣地，為了這個教學，我不會在這上面花太長時間，
因為我真的不認為你想看我一直瀏覽檔案。
但我通常會花半個小時左右，也許更長，
逐一看過它建立的不同檔案，確認所有內容對我來說都是正確的，
確保我理解所有內容，
因為我不希望專案朝著一個我不清楚發生什麼事的方向發展，
所以我要快速看一下這些元件。

12
00:04:47,000 --> 00:05:11,920
首先是按鈕元件，這裡有三個不同的檔案，看起來很簡單。
這裡有一些 props 和 prop 介面，
type 是 submit、reset 或 button 其中之一。
然後是 children，就是我們傳入按鈕的文字，
一個往前傳遞的 onClick 處理器，以及一個 disabled prop。
所以這一切都相當簡單。

13
00:05:11,920 --> 00:05:41,200
然後這裡有一個 class name 為 BTM，這是我們已經建立的，
加上這個特定按鈕的樣式。好的，很棒。所以按鈕就這樣，非常簡單。
輸入元件在這裡，同樣有一些 props，也很簡單。
我們在這裡用 input group 開始。讓我們看一下這個，
是的，那就是模組裡的 input group class。
然後往下這裡是輸入的標籤，我們可以傳入它。

14
00:05:41,880 --> 00:05:47,840
還有輸入本身，帶有 onChange 處理器和 class。
好的，看起來都很不錯。

15
00:05:49,120 --> 00:06:18,160
登入表單本身。好的，就是標準的 React 元件，
往下我們用了一點 state 來處理電子郵件和密碼。
我們有一個提交處理器，阻止預設動作，然後將電子郵件和密碼輸出到主控台。
然後我們使用那些輸入元件和密碼輸入（我們還沒看到的那個），
以及底部的按鈕元件。
我們也有連到註冊頁面的連結。很好。
在我們看密碼輸入之前，先來看看註冊表單。

16
00:06:19,280 --> 00:06:43,120
這看起來很相似。我們再次使用 state。
我們有提交處理器，做類似的事情。
是的，它們看起來都很相似，只是這個在底部換成了連到登入頁面。
好的。然後我們還有這裡的密碼輸入元件。
我們接收所有這些 props，跟其他輸入一樣，
但這次我們有這個 state：visible 和 setVisible。

17
00:06:44,400 --> 00:06:50,640
所以我們應該在某個地方有一個圖示，不是嗎？
找到了。我們有 EyeOff 和 Eye。

18
00:06:51,960 --> 00:07:20,400
當我們點擊其中一個圖示——它其實是一個按鈕，嵌入在一個按鈕裡——
點擊後會切換這個 state 的可見性，所以它會顯示其中一個或另一個。
當 visible 設定為 true 時，它會顯示其中的文字，基本上它會變成一個文字輸入框。
而當 visible 為 false 時，它會變成一個密碼輸入框，從而隱藏文字。

19
00:07:20,560 --> 00:07:45,320
好的，這對我來說都說得通。好的，我們還有什麼？
下面有測試，我認為我們不太需要去看它。
它為每一個元件都建立了測試檔案，同樣地，如果我不是在錄影，我會去看這些。
然後在 app 資料夾裡面，我們應該有那些元件加入到登入頁面，
確實有，這裡是登入表單，還有這裡的註冊頁面。

20
00:07:46,000 --> 00:08:14,080
好的，太棒了，看起來一切都不錯，我現在要做的就是在瀏覽器中預覽一下。
好的，我們在登入頁面上，看起來都很好，
我可以在這裡輸入一些東西，比如 mario@，不知道，pocketheist.com，
然後下面我們輸入密碼 test1234。
如果我點擊這個圖示，這個眼睛圖示，就可以看到密碼了。
嗯，一切都運作正常，滿不錯的。

21
00:08:14,600 --> 00:08:43,880
我們可以在這裡切換到註冊頁面，看起來也不錯。
讓我們確認這個也運作正常。輸入 mario@ph.com，然後建立密碼 test1234。
預設情況下它不顯示。如果我們點擊眼睛圖示，它就會顯示，反之亦然。太棒了。
好的，看起來一切都很好。
因為我現在對這個感到滿意，我可能會把這些變更全部加入暫存區。
讓我在這裡這樣做。

22
00:08:43,880 --> 00:09:12,800
我就說 git add。然後我要使用 commit message 指令來做一次提交。
就這樣做，在這裡輸入 commit -m 然後按 Enter。
這樣就會把它提交到這個分支——
記得我們正在使用的是 claude/feature/authentication-forms 這個分支。
它為我們生成了提交訊息，我說是的，請用那個訊息提交。
好了各位朋友，我們現在完成了這個工作流程的完整一個循環。

23
00:09:12,800 --> 00:09:41,320
我們使用 spec 指令建立了一份高層次的功能規格，
然後我們制定了一份關於如何實作該功能的詳細技術計畫，
最後，我們用那份計畫搭配 Opus 4.5 和延伸思考功能來新增該功能。
就像我之前說的，你可以為這個工作流程加入更多步驟，
也許包括設計參考、程式碼審查等等，我們之後也會做一些這樣的事。
但即使沒有這些，我認為這是一個穩固、簡單的三步驟流程，
你可以用它開始為應用程式新增功能。

24
00:09:42,000 --> 00:10:08,760
到這個時間點，我通常會把這個功能分支推送到 GitHub，
讓它可以被審查後合併到主分支。
但我現在還不想在工作流程中引入 GitHub，
因為後面會有一整個章節專門介紹它。
所以現在，因為我對這個功能的實作完全滿意，
我就在本地合併這個分支，來到對話框並進入 bash 模式，
然後輸入 git switch main 按下 Enter 切換到主分支。

25
00:10:09,440 --> 00:10:34,080
一旦切換到主分支，我們可以再次進入 bash 模式，
然後輸入 git merge，再加上我們想要合併到主分支的分支名稱，來合併功能分支。
完成後，我們就可以按下 Enter 執行指令，
將功能分支合併到主分支，讓主分支包含我們剛剛新增的新功能。
好了，各位朋友，這就是這個免費章節的結尾。
我真的非常希望你從中有所收穫。

26
00:10:34,360 --> 00:11:00,720
就像我之前說的，這只是我最近在 netninja.dev 發布的
完整 Claude Code 大師課程的一小部分。
如果你喜歡這個並想深入了解這個流程、延伸這個流程，
以及學習 MCP 伺服器、子代理和更新的 Claude Code 網頁工具等其他主題，
那一定要去看看這門課程。
只要 15 美元，而且如果你使用優惠碼 ClaudeNinja 可以以半價購買，
但那個優惠碼將在幾週後過期。

27
00:11:01,040 --> 00:11:21,520
另外，如果你想存取我的整個課程庫，
包括這門 Claude Code 大師課程、另外九門大師課程，以及其他獨家教學，
你可以訂閱 NetNinja Pro。
每月只要 9 美元，而且使用這裡的優惠碼，你可以以半價享受第一個月。
無論如何，我真的希望你喜歡這個章節，我們下個系列見。

