1
00:00:02,240 --> 00:00:13,360
好的，在這堂課中，我們要來看看 Claude Code 的規劃模式（plan mode），
這是一個唯讀模式，專門用來為新功能建立實作計畫，
就像我們在上一堂課規格化的那個功能。

2
00:00:13,840 --> 00:00:39,520
當我們使用規劃模式建立計畫時，Claude Code 會啟動一個叫做子代理（sub-agent）的東西，
它的專長是研究並收集關於程式碼庫及任何額外上下文的資訊。
這個子代理負責將那些資訊回傳給 Claude 這個主代理，
主代理再生成一個計畫 markdown 檔案，
其中包含實作計畫的完整指令，
包括程式碼範例、檔案結構、樣式指南等等。

3
00:00:40,400 --> 00:00:57,760
一旦有了計畫，我們就可以要求 Claude Code 用它來實作所描述的任何新功能。
加入建立計畫這個步驟是很好的，尤其對於多步驟的複雜功能，
因為它允許根據你目前的程式碼庫進行徹底的研究，找出最佳的實作方式。

4
00:00:58,200 --> 00:01:15,440
因此，你得到的是一份基於程式碼庫分析的完整指南，
說明如何以最佳方式將該功能加入專案，而不只是靠猜測。
此外，有了計畫文件，模型在需要時可以隨時回頭參考，
並在進行提議的程式碼變更時追蹤自己的進度。

5
00:01:15,840 --> 00:01:34,000
我發現這樣能讓事情更有條不紊，並產出更可靠的結果。
最後，由於我們是在進行任何程式碼變更之前建立計畫文件，
我們隨時可以在使用之前自己手動調整那份計畫。
那麼，讓我們使用這個規劃模式，根據上一堂課建立的規格建立一個新計畫。

6
00:01:34,480 --> 00:02:04,360
首先我們需要進入規劃模式，方法是按下 Shift + Tab 來循環切換，
先經過自動接受編輯模式，再到規劃模式。
你隨時可以看出自己是否在規劃模式，因為下方會以綠色顯示。
不過，一般情況下沒有規格文件時，你可以傳送一個通用的提示，
例如「你能規劃登入和註冊頁面的身份驗證表單嗎？」
它也能為此做出一個不錯的計畫。
但是，我們已經建立了一份非技術性的規格文件來描述該功能，
所以我們可以告訴 Claude 規劃那份規格中概述的功能，

7
00:02:04,680 --> 00:02:33,800
其中包含了比直接在提示中寫幾句話多得多的細節，
說明我們對這個功能的期望。
這就是我為什麼要先建立規格檔案，
因為它提供了功能的高層次但詳細的概述——
從使用者角度看功能應該如何運作，以及需要注意的邊緣情況等等。
所以我們現在要開啟那個規格檔案，
這樣當我們把游標放在裡面時，它就會自動作為上下文加入到提示中。
然後我在下面輸入，

8
00:02:34,520 --> 00:02:59,760
「規劃這份規格中描述的功能。」好的。
然後這樣做完之後，我們就可以按下 Enter。
這樣做之後，Claude Code 會開始執行子代理來探索程式碼庫並進行一些研究。
過程中我會授予它所需的任何權限，
偶爾可能是用來列出檔案的 bash 指令之類的。
所以我現在要加速播放，等它完成後再回來。

9
00:03:10,160 --> 00:03:34,440
好的，它已經完成了。
如果你在對話框中稍微往上捲動，
應該能看到計畫的簡短摘要，但可能不是全部。
完整的計畫檔案實際上儲存在你電腦主目錄的 .claude 資料夾裡，
而不是在目前的專案目錄中。
它也在下方詢問我們是否要立即實作這個計畫，並在過程中允許編輯。
但是，我不喜歡立刻就實作任何東西。

10
00:03:34,560 --> 00:03:57,600
我喜歡先自己看過計畫，確認所有內容都正確。
如果有不正確的地方，我可以手動修改。
所以我要往下選到最底部的選項，說：
不，先把計畫儲存到 _plans 資料夾留著以後用。
我也知道這個專案裡目前根本沒有 _plans 資料夾。
所以在我們送出回應之前，

11
00:03:57,960 --> 00:04:25,360
我們需要在根目錄這裡建立那個資料夾。
其實，即使我們沒有先建立這個資料夾，Claude Code 也可能會自己想辦法幫我們建立。
那麼，現在我們可以送出回應，
希望 Claude 會將那個計畫檔案放進 plans 資料夾裡。
好的，我想它已經做到了。
如果我們現在看一下那個檔案，可以讀過整個計畫。
同樣地，我不打算花太長時間在這上面，因為那是一個超長的檔案。

12
00:04:25,960 --> 00:04:54,400
我很清楚讓你看著我把這全部唸一遍會很無聊，所以我們只是快速瀏覽一下。
通常，就像我之前說的規格一樣，我會在這份計畫上花更長的時間，
10 分鐘、15 分鐘、有時甚至 20 分鐘，確保在繼續之前一切都絕對正確。
無論如何，頂部有一個概述，是要為這些頁面實作功能性的身份驗證表單等等。
首先，它列出了一堆需要建立的關鍵檔案和新元件，
它決定我們需要一個 input（輸入）

13
00:04:55,120 --> 00:05:23,920
文字輸入的元件，連同對應的 CSS 模組和 barrel export（桶狀匯出）。
密碼輸入也一樣。這裡還有一個自訂按鈕也一樣。
然後我們要有一個登入表單的元件。
好的，所以它不是直接在表單本身、也就是頁面本身裡建立範本，
而是為此建立一個元件，這樣我也沒意見。
註冊表單也一樣。
還有需要更新的額外頁面，就是登入和註冊頁面，
這些是我們需要對它們進行的更新。

14
00:05:24,760 --> 00:05:41,120
然後是要建立的測試檔案，每個不同元件都有測試檔案。
接著是實作步驟，這就是計畫本身了。
這些是它需要建立的所有東西，這就是計畫。
所以步驟一，建立輸入元件，這裡有一些關於如何做到這一點的詳細說明。

15
00:05:41,880 --> 00:06:10,440
往下是樣式方法：使用 @apply 套用 Tailwind 工具類、
引用主題變數來設定顏色、用主要顏色設定聚焦狀態的樣式、
為輸入欄位加上邊框和內距。好的，都很不錯。
建立密碼輸入元件，大概跟這個差不多。
然後是圖示用法，它展示如何為密碼欄位使用圖示。
我們有 Eye 和 EyeOff，它們來自我們目前使用的圖示套件。很好。
下面的樣式方法也一樣。

16
00:06:11,840 --> 00:06:36,800
然後我們有建立按鈕元件的步驟。好的，看起來不錯。
然後是實作部分：按鈕預設使用 type="submit"、
支援帶有降低透明度的停用狀態、保留按鈕類別中現有的懸停過渡效果。
那是我們已經建立了 button class 的地方。
就像我說的，這就是規劃模式真正厲害的地方。
它不是從頭開始建立這份計畫，好像我們有一個空白專案一樣，
而是先看過我們的專案。

17
00:06:37,280 --> 00:06:58,400
它看到我們有這個 button class，
它看到我們以這種方式建立元件——每個元件有三個不同的檔案。
它看到我們在 CSS 模組裡使用 Tailwind 的 @reference 指令，
所以它探索了程式碼庫，並根據我們目前的專案制定計畫，
這就是為什麼這麼厲害。

18
00:06:59,000 --> 00:07:26,560
好的，往下我們有建立登入元件的步驟。
它要建立帶有 email 匯入的登入表單元件、密碼輸入元件、提交按鈕元件等等。
所以它先建立所有那些 UI 元件，然後把它們組合在登入表單中。
這裡有一個程式碼範例，說明如何使用 input、password input 和 button 元件來建立它。
我們也有這個連結，用來切換到註冊頁面。

19
00:07:27,440 --> 00:07:55,440
關於處理器，我們有：阻止預設的表單提交行為、
將電子郵件和密碼輸出到主控台、
使用 React state 的受控輸入，以及一些驗證標準。
然後下一步是建立註冊表單元件，跟登入那個差不多。
然後我們更新登入頁面和註冊頁面，加入那些登入元件和註冊元件。
接著我們在這裡建立測試來測試所有東西，我們有

20
00:07:56,200 --> 00:08:25,280
每個不同元件都有各自的測試指南，這很好。
往下有一些設計決策。
好的，元件架構基本上在說明我們為什麼要做某些事，這很棒。
它說要將登入表單和註冊表單元件分開，
雖然它們很相似，但我們保持分開，
這遵循了單一職責原則，也讓未來的分歧更容易處理。
嗯，我同意這一點。
可重用的輸入元件，input 和 password input 可以在整個應用程式中重用，同樣地，我喜歡這樣。

21
00:08:25,800 --> 00:08:51,840
按鈕元件也一樣。樣式策略——就是一些我們之前看過的東西。
表單狀態管理，我們會使用 state。
這裡有一個驗證方法。
然後是表單之間的導覽，它使用的是 Link 元件。
技術考量——我們為不同的 props 建立 TypeScript 介面，
例如這裡的 input props。無障礙性。

22
00:08:52,680 --> 00:09:20,080
嗯，aria 標籤等等，圖示整合——就是我們使用的各種圖示。
它根據 claude.md 檔案抓到了我們不想使用分號的設定，這很棒。
我們也有一些驗證步驟，可以做視覺檢查、功能檢查等等。
這真的是一份非常詳盡的計畫。
好的，我真的很喜歡這個功能。
如果我只是在對話框中用自己的提示，

23
00:09:20,760 --> 00:09:46,320
它不會費這麼大的功夫來確保這個功能正確地融入我們的專案，
也不會與我們建立的那份詳細高層次規格相配合。
我認為這對於新增功能來說非常強大，這也是我喜歡的工作方式。
好了，各位朋友。
現在我們已經完成前兩個步驟了，對吧？
我們建立了一份高層次的非技術性規格，
現在我們也建立了一份更詳細的技術計畫。

24
00:09:46,960 --> 00:10:06,800
接下來，我們只需要使用這份計畫來實作功能，
這將在下一堂課中使用延伸思考模式來完成。
但在這之前，我通常會在這個時間點做一次提交，
將新的規格檔案和計畫檔案提交到歷史記錄中。
這樣的話，如果實作進行得不順利，
我們隨時可以回到這個提交，在進行任何程式碼變更之前重新嘗試。

